///////////////////////////////////////////////////////////////////////////////
The implementation of convert_grammar was madde by intially observing the 
difference between the two grammars and mapping that to the function skeleton
provided. The start word was kept the same, but the rest of the rules had to be
converted to fit the function form of the second. This was done by reading the
list of rules and recursively prepending the new rule to a recursive call onto
the rest of the list of rules.

I originally tried to modify the solution for the old projects for DNA to 
match the specs for this project. however, while reviewing the functions 
helped to clarify my understanding of what we had to program and further
familiarize myself with OCaml and functional programming, it was easier just
to write new fucntions rather than forceable modify the preexisting ones
given how different the actual problem was.

The grammer was split like last time to a start symbol and rule, though in 
this case, the rule was on the form of a function. Thus from the function 
skeleton provided (a currying function that returns a matcher), the grammer was
first split into the start symbol and rules. Using these, we would call the 
matcher and pass them both, along with a set of rules generated by calling the
grammar's function on the start symbol. This function call was orginally
placed in the matcher rather than than parse_prefix, but it was moved as the
matcher wishes to immeditely match using said list of rules. Along with this
list, we need to pass in the acceptor, which acts upon the fragment mentioned 
in the spec.

Again following the spec, the matcher would then go through the rules given 
for the symbol and match through the list. Then I would alctually have to 
verify the rule. it was originally written inside matcher, since I would have
to call the matcher if I hit a non-terminal, but then I relizaed I would also
have to then check the path going down that matcher and so forth and so on.
Luckily, my TA mentioned how to write mutually recursive functions, so I split
off the code to be a seperate function that I could call, that being 
match_path. Depending on results, I would then do one of 2 options: if 
match_path returned None, it means it failed and then I would proceed to try 
and perform a matching with the next rule in the list by recursively calling 
matcher with the tail of the rules list for that start symbol. Otherwise,
it means that match_path succeeded and that I could simply return the return of
match_path. To make the code easier to read, I store the function call before
the if statement. This is also where the new rule derivaion is stored in
derivation with an append. (Originally te stored function call was to reduce 
the number of times the function was being called before I remembered I was 
coding in Ocaml, not C). As a side note, the formatting of the code is arranged
in a style reminiscent of Python partially to make it easier to read and for 
the sake of my sanity.

match_path then checks the path given the rule that is currently chosen. Given
an empty list (used for the recursive calls) siply call the current acceptor.
Besides this, there are only two possibilities: a nonterminal or a terminal.
For the nonterminal, this means we need to do another call to matcher and go
"further down" the grammar tree. However, we have to modify the acceptor since
we need to match the rest of the pattern from the rule we're checking, with
the rest of the pattern being what is stored in rhs after matching the first
symbol. Else if the symbol is terminal, we check if the first part of the 
fragment matches. If it does, great, continue checking by recursively calling
match_path with the remainder of the rule pattern and the remainder of the
fragment. Else, we return None, which will be passed back into matcher, where
the whole process will start again with the next rule.

The main weakness of this program is that it is highly depened on the grammar.
Meaning that any issues with the grammar will cause the program to fail. One
key example would be the topic of homework 1, blind alley rules. If these rules
exist within the grammar, the program would just go into an infinite loop as it
goes into deeper and deeper recursion. Simularly, if a Nonterminal symbol
points to itself immediately within the grammar, it would also loop, forming a
blind alley rule with itself, as the program goes down the list in the given.
The program also works in a left-associative manner, due to h::t notation in 
OCaml. Along the same vein, another dependency on grammar is that the program 
just looks for a match, not the "best match", again being ased on the order of
the grammar rules. Also, perhaps needless to mention, errors in the grammar are
not handled at all, but due to the nature of OCaml, the errors are reported. In
many cases, it could argued that the program works to spec, and issues are 
within the input grammars.